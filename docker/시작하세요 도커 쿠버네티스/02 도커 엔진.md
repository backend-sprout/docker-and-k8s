# 도커 엔진 
# 도커 이미지와 컨테이너 

## 도커 이미지 

**도커 이미지**
* 여러 개의 계층으로 된 바이너리 파일로 존재
* 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용

```
kwj1270/imagename:1.0.1
[저장소][이미지이름][태그]

imagename:1.0.1
[이미지이름][태그]
```
도커 이미지는 일반적으로 `[저장소이름]/[이미지이름]:[태그]` 형태로 구성되어 있다.  

* 저장소 : 
    * 이미지가 저장된 장소 
    * 저장소가 없으면 도커에서 기본 제공하는 도커 허브의 공식 이미지
* 이미지 이름:
    * 이름(어떤 역할을 하는지)
    * 생략할 수 없음   
* 태그 : 
    * 이미지의 버전 관리, 리비전 관리에 사용
    * 태그를 생략하면, latest로 인식(최신)


## 도커 컨테이너 

**이미지를 기반으로 컨테이너를 생성한다면? 🤔**   
* 파일이 들어 있는 파일시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생김   
* 대부분의 컨테이너는 생성될 때, 알맞은 설정 파일을 가지고 있다.    
   
컨테이너는 읽기 전용으로 사용하되,      
이미지에서 변경된 사항만 컨테이너 계층에 저장하므로     
컨테이너에서 무엇을 하든지 **원래 이미지는 여향을 받지 않는다.**      
  
또한, 컨테이너 각기 독립된 파일시스템을 제공받으며 호스트와 분리돼있으므로     
특정 컨테이너에서 어떤 애플리케이션을 설치하거나 삭제해도 다른 컨테이너와 호스트는 변화가 없다.  

# 도커 컨테이너 다루기 

컨테이너 대상 모든 명령어들은 컨테이너의 이름 대신 ID 사용이 가능하다.     
그리고 너무 길때는 고유한 글자들만 입력해도 된다.     

## 컨테이너 생성 

![images_hanif_post_bf1022b7-d84a-47e3-86e6-aa4d3d8d3599_image](https://user-images.githubusercontent.com/50267433/173092086-96247da8-2903-433b-a4cf-b5e3421b6d2e.png)

```
docker run 저장소/이미지:태그 (run -> create -> start -> attach)
docker create 저장소/이미지:태그(컨테이너만 생성)
docker start 저장소/이미지:태그(컨테이너 실행..? -> 이부분 확인좀)
docker attach 저장소/이미지:태그(컨테이너 접속)
```

**옵션**
* -i : 상호 입출력
* -t : tty를 활용해서 배시 셸 사용 
* --name : 컨테이너 이름 지정(유용) 
* -p : 포트 바인딩 
* -d : detach 모드로 백그라운드 실행(입출력 없는 상태로 실행, 포그라운드로 실행)
* -e : 컨테이너 내부 환경 변수 설정(docs 참조) 
* --link : IP가 아닌 컨테이너 별명으로 컨테이너끼리 접근하는 기술,(타겟_컨테이너/타겟_별칭) 
    * 현재는 deprecated -> 도커 브릿지를 이용 


### 컨테이너 내부
```
root@0f4c5b82c03f:/#
```
* 컨테이너 기본 사용자는 root
* 호스트 이름은 무작위 16진수 해쉬값(컨테이너 고유 ID 앞부분) 

```
root@0f4c5b82c03f:/# exit
```
* exit 명령어로 탈출 가능 


### 버전 확인
```
docker -v
```

### 이미지 확인
```
docker images
```

### 컨테이너 목록 확인

```
docker ps 
```
* 정지되지 않는 컨테이너 목록 출력 

```
docker ps -a
```
* 모든 컨테이너 목록 출력 

**컨테이너 목록 항목 설명**   
* CONTAINER ID : 
    * 컨테이너에게 자동으로 할당되는 고유한 ID 
    * 목록 출력시 일부만 나오지만, docker inspect 명령어 사용시 전체 ID 확인 가능 
* IMAGE : 
    * 컨테이너를 생성할 때 사용된 이미지의 이름
* COMMAND : 
    * 컨테이너 시작시 실행될 명령어
    * 이미지에 내장된 커멘드는   
      docker run 이나 create 명령어의 맨 끝에 입력해서 컨테이너를 생성할 때 덮어 쓸 수 있다.
    * docker run 저장소/이미지:태그 명령어
* CREATED :
    * 컨테이너가 생성되고 난 뒤 흐른 시간을 나타낸다.   
* STATUS :  
    * 컨테이너 상태
        * Up : 실행중
        * Exited : 종료된 상태
        * Pause : 일시 중지 
* PORTS : 
    * 컨테이너가 개방한 포트와 호스트에 연결한 포트를 나열한다. 
* NAMES : 
    * 컨테이너 고유 이름
    * --name 옵션 : 지정 이름
    * 미옵션 : 형용사와 명사 무작위 조합  

### 컨테이너 삭제

```
docker stop 이미지_이름(or ID)
```
* 컨테이너 중지 

```
docker rm 이미지_이름(or ID)
```
* 컨테이너 삭제(중단된 상태에서 가능)
* -f 옵션으로 강제 삭제 가능하다.

```
docker container purne
````
* 모든 컨테이너 삭제 

```
docker stop $(docker ps -a -q)
docker stop $(docker ps -a -q)
```
* 아이드를 통해 삭제하는 방법 
* -a : 모든 컨테이너
* -q : 컨테이너 ID 만 출력 

## 컨테이너 외부 노출 

**컨테이너는 가상 머신과 마찬가지로 가상 IP 주소를 할당 받는다.**      
기본적으로 `172.17.0.x` IP를 순차적으로 할당한다.  
아무런 설정을 하지 않았다면, 컨테이너 외부에서 접근할 수 없으며 도커가 설치된 호스트만 접근이 가능하다.   
   
외부에 컨테이너 애플리케이션을 노출하기 위해서는     
**eth0의 IP와 포트를 호스트의 IP와 포트에 바인딩 해야한다.**  

```
docker run -p 호스트포트:컨테이너포트 저장소/이미지:태그 
```
* 바인딩할 포트와 공개할 포트를 작성한다.    
* 애플리케이션은 각각의 포트를 사용하는데 그 포트로 여는 것이 좋다.  
* 정확히 말하면 `호스트 IP의 80번 포트` -> `80번 포트는 컨테이너의 80번 포트로 포워딩` -> `웹 서버 접근`
 
```
docker run -p 호스트포트:컨테이너포트 -p 호스트포트:컨테이너포트 저장소/이미지:태그 
```
* 여러 포트를 바인딩 할 수 있다. 

## 컨테이너 애플리케이션 구축  

대부분의 서비스는 단일 프로그램이 아닌,     
여러 에이전트나 데이터베이스등과 연결되어 완전한 서비스로써 동작하는것이 일반적    
  
이런 구성요소들을 하나의 이미지로 만들고 실행하지 않고  
긱 칸테이너마다 하나의 애플리케이션을 구동시키면, 독립성 보장과 동시에 버전관리, 모듈화등이 쉬워진다.    

## 도커 볼륨 

도커 이미지로 컨테이너를 생성하면 이미지는 읽기 전용이 되며     
컨테이너의 변경 사항만 별도로 저장해서 각 컨테이너의 정보를 보존한다.  
즉, 이미지는 어떠한 경우도 변경되지 않으며 컨테이너 계층에 원래 이미지에서 변경된 파일 시스템들을 저장한다.    
 
그러나 이는, 컨테이너마다 데이터가 초기화 된다는 것을 의미하기도 한다.       
이를 방지하기 위해 컨테이너의 데이터를 영속적 데이터로 활용할 수 있는 방법들이 여럿 있다.  
그 중에서 볼륨을 확인해보자.   

* 호스트와 볼륨 공유
    * 호스트와 컨테이너의 디렉터리가 공유되는 방식  
    * `-v [호스트의 공유 디렉터리]:[컨테이너의 공유 디렉터리]` 
    * 호스트의 디렉터리가 없었어도 알아서 만들어준다.  
    * 동기화가 아니라 완전히 같은 디렉터리이다.  
    * 디렉터리 뿐만 아니라 파일 단위의 공유도 가능하며, 여럿도 가능하다.  
    * 만약 디렉터리가 같다면 -> host 디렉터리로 덮어진다.(파일도 host 의 파일로)
* 볼륨 컨테이너
    * 볼륨을 사용하는 다른 컨테이너와 공유하는 방식
    * --volumes-from 옵션을 통해 이미 -v(-volume)으로 만들어진 컨테이너와 볼륨 공유 
    * `--vloumes-from -v 된 컨테이너 이름`
    *  이를 잘 활용하면 볼륨 컨테이너를 만들어서 활용 가능 
* 도커가 관리하는 볼륨 생성  
    * docker volume 명령어를 활용 
    * 생성 : `docker volumne create --name [볼륨 이름]` or `-v [컨테이너 디렉터리]`
    * 사용 : `docker run [저장소]/[이미지]:[태그] -v [볼륨이름]:[컨테이너 디렉터리]`
        * 이후, 컨테이너 디렉터리에서 파일을 생성하면 볼륨에 넣어진다.  
        * 호스트와 정반대로 보면됨 
        * 이후 볼륨을 사용한 컨테이너는 파일 공유(컨테이너내 다른 디렉토리로도 가능)  
    * docker inspect 를 사용하면 실제로 어디에 저장되는지 알 수 있다.
        * `docker inspect --type volume [볼륨 이름] ` 
        * `docker container inspect [컨테이너 이름]`
    * 삭제 : `docker volume prune`  
 
컨테이너가 아닌 외부의 데이터를 저장하고        
컨테이너는 그 데이터로 동작하도록 설계하는 것을 stateless라고 말한다.     
컨테이너 자체가 상태가 없고 상태를 결정하는 데이터는 외부로부터 제공받는 것     
컨테이너가 삭제돼도 데이터는 보존되므로 스테이트리스한 컨테이너 설계는 도커를 사용할 때 매우 바람직   

```
-v 대신 --mount 가능 대신, 사용법이 조금 다름

# 도커 볼륨 마운트 
docker run -i -t --name 이름 \
--mount type=volume, source=myvolume, target=/root \
이미지:태그 

# 호스트 디렉토리 마운트 
docker run -i -t --name 이름 \
--mount type=bind, source=/hosts/, target=/root \
이미지:태그
```

## 도커 네트워크 
### 도커 네트워크 구조 

도커 컨테이너에 내부 IP를 순차적으로 할당하며,    
이 IP는 컨테이너를 재시작할 때마다 변경될 수 있다.(내부망)   
  
도커는 외부와 연결될 필요가 있는데      
컨테이너 시작할 때마다 호스트에 veth라는 네트워크 인터페이스를 생성함으로써 이루어진다.  
    
도커는 각 컨테이너에 외부와의 네트워크를 제공하기 위해     
컨테이너마다 가상 네트워크 인터페이스를 호스트에 생성하며 이 인터페이스의 이름은 veth로 시작한다.    
veth 인터페이스는 사용자가 직접 생성할 필요는 없으며 컨테이너가 생성될 때 도커 엔진이 자동으로 생성한다.   

```
host 에서 ifconfig

eth0 : ~~~
veth0 : ~~~
docker0 : 
```
* eth0 : 공인 IP 또는 내부 IP가 할당되어 외부와 통신할 수 있는 호스트의 네트워크 인터페이스
* veth0 : 컨테이너 시작시 생성되며, 각 컨테이너의 eth0과 연결 
* docker0 : 브리지, 각 veth 인터페이스와 바인딩돼 호스트의 eth0 인터페이스를 이어주는 역할  

<img width="530" alt="docker-network" src="https://user-images.githubusercontent.com/50267433/173175743-d787ea32-579c-45ed-bfb1-0de03de8cdea.png">
 
정리하면       
* 컨테이너 eth0 <-> 호스트의 veth.. 연결   
* 호스트의 veth.. <-> 호스트의 docker0 브리지와 바인딩   
* 호스트의 docker0 브리지와 바인딩 <->  호스트의 eth0   
  
`brctl show docker0`하면 실제로 veth가 바인딩 되었는지 확인 가능하다. 
 
 ### 도커 네트워크 기능 
 
 컨테이너는 docker0 브리지를 통해 외부와 통신 가능하지만, 선택에 따라 네트워크 드라이버를 선택할 수 있다.   
 
 * 도커 자체 제공 : `bridge`, `host`, `none`, `container`, `overlay`   
 * 써드 파티 : `weave`, `flannel`, `openvswitch` 

```
docker network ls 

> NETWORK ID        NAME        DRIVER        SCOPE
```
```
docker network inspect bridge

> Config : [
    {
        Subnet : 172.17.0.0/16,
        Gateway : 172.17.0.1
    }
]
```
아무런 설정을 하지 않고 컨테이너를 생성하면 자동으로 docker0 브리지를 사용한다.   

#### 브리지 네트워크 

**브리지 네트워크**는 docker0이 아닌    
사용자 정의 브리지를 새로 생성해 각 컨테이너에 연결하는 네트워크 구조     
컨테이너는 연결된 브리지를 통해 외부와 통신할 수 있다.     
   
**docker network create**
``` 
docker network create --driver bridge [브리지 이름]
````
* 도커 네트워크 생성 

**브리지 사용**      
```
docker run -i -t --name 네트워크_이름 \
--net [브리지 이름]
[이미지]:[태그]
```    
* docker run 또는 create 명령어에 `--net 옵션`의 값을 설정하면 컨테이너가 이 네트워크를 사용하도록 설정 가능하다.    
   
이후 컨테이너 내부에서 ifconfig를 입력하면, **새로운 IP 대역이 할당된 것이다.(172.17.0.0 -> 172.18.0.0)**                 
브리지 타입의 네트워크를 생성하면 도커는 IP 대역을 차례대로 할당한다.          
이렇게 생성된 사용자 정의 네트워크는 docker network disconnect, connect 를 통해 컨테이너에 유동적으로 붙이고 땔 수 있다.       
   
```
# docker network disconnect [브리지이름] [컨테이너]  
# docker network connect [브리지이름] [컨테이너]      
``` 

네트워크의 서브넷, 게이트웨이, IP 할당 범위 등을 임의로 설정하려면     
네트워크를 생성할 때 아래와 같이 한다.    

```
docker network create --driver=bridge \
--subnet=172.72.0.0/16 \
--ip-range=172.72.0.0/24 \
--gateway=172.72.0.1 \
my_custom_network
```
* 단, subnet과 ip-rnage 는 같은 대역이어야 한다.    

#### 호스트 네트워크 

네트워크를 호스트로 설정하면, 호스트의 네트워크 환경을 그대로 사용할 수 있다.    

```
docker run --net host \
[이미지]:[태그]
```
* 이후 ifconfig 를 사용하면, 호스트의 네트워크 환경과 동일함을 알 수 있다.     
* 호스트 이름도 물려받기에 컨테이너의 호스트 이름도 호스트 머신의 호스트 이름으로 설정된다.     
* 별도의 포드 포워딩 없이도 바로 서비스 할 수 있다.(외부에 노출과 비슷) 

#### 논 네트워크

말그대로 아무런 네트워크를 쓰지 않는 것    

```
docker run --net none \
[이미지]:[태그]
```
* ifconfig 로 확인하면 자신을 나타내는 lo 말고는 나오지 않는다.  


#### 컨테이너 네트워크 

`--net` 옵션으로 conatiner를 입력하면 다른 컨테이너의 네트워크 네임스페이스 환경을 공유할 수 있다.   

**공유되는 속성**   
* 내부 IP
* 네트워크 인터페이스의 MAC 주소 
* 기타 등등 

```
docker run --net conatiner:[컨테이너 이름] \
[이미지]:[태그]
```
* 다른 컨테이너의 네트워크 환경을 공유하면 내부 IP를 할당받지 않으며  
  호스트의 veth로 시작하는 가상 네트워크 인터페이스도 생성되지 않는다.       
* 그러나 타겟이 문제가 생기면 veth 가 없어 네트워크가 단절되지 않을까?   

#### 브리지 네트워크와 --net-alias

run 명령어에 `--net-alias`를 같이 사용하면, 특정 호스트 이름으로 컨테이너 여러개에 접근이 가능하다.   

```
docker run --net-alias 별칭 [이미지]:[태그]
docker run --net-alias 별칭 [이미지]:[태그]
docker run --net-alias 별칭 [이미지]:[태그]
```
```
ping -c 1 별칭
```
* 컨테이너 3개의 ping 요청이 들어갔다.    
* 매번 달라지는 IP를 결정하는 것은 별도의 알고리즘이 아닌 라운드 로빈 방식이다.     
* 도커엔진에 내장된 DNS가 호스트 이름을 별칭을 가진 컨테이너로 변환하기 때문이다.(IP 목록)      

![1_5Ts6bzLOp07PO08BYO4VVQ](https://user-images.githubusercontent.com/50267433/173177257-03ed1db6-715d-46b6-b768-0f2efd092182.png)
 
도커의 DNS는 호스트 이름으로 유동적인 컨테이너를  찾을 때 주로 사용한다.    
`--link`가 대표적인데 컨테이너의 IP가 변경돼도 별명으로 컨테이너를 찾을 수 있게 DNS에 자동으로 관리  
단, 디폴트 브리지 네트워크의 컨테이너 DNS 라는 점이 다르다.   
  
`--net-alias` 비슷한 원리    
도커는 기본 브리지 네트워크가 아닌 사용자가 정의한 브리지 네트워크에 사용된 내장 DNS 서버를 가진다.     
그리고 별칭을 사용한 컨테이너의 IP는 DNS 서버에 별칭 호스트 이름으로 등록된다.     

`dig`라는 도구를 사용하여 호스트 이름을 검색하면 아래와 같이 나온다.  
```
dig 별칭 

별칭 600 IN A 172.18.0.5
별칭 600 IN A 172.18.0.4
별칭 600 IN A 172.18.0.3
```

#### MacVLAN 네트워크 
MacVLAN 은 호스트의 네트워크 인터페이스 카드를 가상화해 물리 네트워크 환경을 컨테이너에게 동일하게 제공한다.   
즉, 컨테이너는 물리 네트워크상에서 가상의 Mac 주소를 가지며 해당 네트워크에 연결된 다른 장치와 통신이 가능해진다.   

![그림2](https://user-images.githubusercontent.com/50267433/173177750-7385ae4d-7ddb-46d2-b613-2a03b6f8ed88.png)

```
공유기 네트워크 정보 : 192.168.0.0/24
서버 1 : 192.168.0.50
서버 2 : 192.168.0.51
```
```
# 서버1
docker network create -d macvlan --subnet=192.168.0.0/24 \
--ip-range=192.168.0.64/28 --gateway=192.168.0.1 \
-o macvlan_mode=bridge -o parent=eth0 my_macvlan

# 서버2
docker network create -d macvlan --subnet=192.168.0.0/24 \
--ip-range=192.168.0.128/28 --gateway=192.168.0.1 \
-o macvlan_mode=bridge -o parent=eth0 my_macvlan
```
* -d : 네트워크 드라이버로 macvlan을 사용한다는 것을 명시(--drive와 동일) 
* --subnet : 컨테이너가 사용할 네트워크 정보를 입력한다. 여기서는 네트워크 장비의 IP 대역 기본 설정을 그대로 따른다.  
* --ip-ranage :   
    * MacVLAN 을 생성하는 호스트에서 사용할 컨테이너의 IP 범위를 입력한다.
    * node01과 node02의 IP 범위가 겹처 동일한 IP의 컨테이너가 각가 생성된다면 정상 동작 안될수 있으므로 겹치지 않게 설정 
* --gateway : 네트워크에 설정된 게이트웨이를 입력한다. 여기서는 네트워크 장비의 기본 설정을 그대로 따른다.  
* -o : 네트워크의 추가적인 옵션을 설정한다.

```
# 서버1
docker run --network my_macvlan 이미지:태그

# 서버 2
docker run --network my_macvlan 이미지:
```
* 이제 두 서버는 동일한 대역대의 네트워크를 가지게 된다.  


## 컨테이너 로깅 
컨테이너 내부에서 일어나는 일에 대한 로깅은 디버깅뿐 아니라 운영측면에서도 효과적이다.     
도커는 컨테이너의 표준 출력과 에러 로그 별도의 메타데이터 파일로 저장하며 이를 확인하는 명령어를 제공한다.  


### json-file 로그 


























 
