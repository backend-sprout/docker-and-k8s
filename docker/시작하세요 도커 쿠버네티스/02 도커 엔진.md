# 도커 엔진 
# 도커 이미지와 컨테이너 

## 도커 이미지 

**도커 이미지**
* 여러 개의 계층으로 된 바이너리 파일로 존재
* 컨테이너를 생성하고 실행할 때 읽기 전용으로 사용

```
kwj1270/imagename:1.0.1
[저장소][이미지이름][태그]

imagename:1.0.1
[이미지이름][태그]
```
도커 이미지는 일반적으로 `[저장소이름]/[이미지이름]:[태그]` 형태로 구성되어 있다.  

* 저장소 : 
    * 이미지가 저장된 장소 
    * 저장소가 없으면 도커에서 기본 제공하는 도커 허브의 공식 이미지
* 이미지 이름:
    * 이름(어떤 역할을 하는지)
    * 생략할 수 없음   
* 태그 : 
    * 이미지의 버전 관리, 리비전 관리에 사용
    * 태그를 생략하면, latest로 인식(최신)


## 도커 컨테이너 

**이미지를 기반으로 컨테이너를 생성한다면? 🤔**   
* 파일이 들어 있는 파일시스템과 격리된 시스템 자원 및 네트워크를 사용할 수 있는 독립된 공간이 생김   
* 대부분의 컨테이너는 생성될 때, 알맞은 설정 파일을 가지고 있다.    
   
컨테이너는 읽기 전용으로 사용하되,      
이미지에서 변경된 사항만 컨테이너 계층에 저장하므로     
컨테이너에서 무엇을 하든지 **원래 이미지는 여향을 받지 않는다.**      
  
또한, 컨테이너 각기 독립된 파일시스템을 제공받으며 호스트와 분리돼있으므로     
특정 컨테이너에서 어떤 애플리케이션을 설치하거나 삭제해도 다른 컨테이너와 호스트는 변화가 없다.  

# 도커 컨테이너 다루기 

컨테이너 대상 모든 명령어들은 컨테이너의 이름 대신 ID 사용이 가능하다.     
그리고 너무 길때는 고유한 글자들만 입력해도 된다.     

## 컨테이너 생성 

![images_hanif_post_bf1022b7-d84a-47e3-86e6-aa4d3d8d3599_image](https://user-images.githubusercontent.com/50267433/173092086-96247da8-2903-433b-a4cf-b5e3421b6d2e.png)

```
docker run 저장소/이미지:태그 (run -> create -> start -> attach)
docker create 저장소/이미지:태그(컨테이너만 생성)
docker start 저장소/이미지:태그(컨테이너 실행..? -> 이부분 확인좀)
docker attach 저장소/이미지:태그(컨테이너 접속)
```

**옵션**
* -i : 상호 입출력
* -t : tty를 활용해서 배시 셸 사용 
* --name : 컨테이너 이름 지정(유용) 
* -p : 포트 바인딩 
* -d : detach 모드로 백그라운드 실행(입출력 없는 상태로 실행, 포그라운드로 실행)
* -e : 컨테이너 내부 환경 변수 설정(docs 참조) 
* --link : IP가 아닌 컨테이너 별명으로 컨테이너끼리 접근하는 기술,(타겟_컨테이너/타겟_별칭) 
    * 현재는 deprecated -> 도커 브릿지를 이용 


### 컨테이너 내부
```
root@0f4c5b82c03f:/#
```
* 컨테이너 기본 사용자는 root
* 호스트 이름은 무작위 16진수 해쉬값(컨테이너 고유 ID 앞부분) 

```
root@0f4c5b82c03f:/# exit
```
* exit 명령어로 탈출 가능 


### 버전 확인
```
docker -v
```

### 이미지 확인
```
docker images
```

### 컨테이너 목록 확인

```
docker ps 
```
* 정지되지 않는 컨테이너 목록 출력 

```
docker ps -a
```
* 모든 컨테이너 목록 출력 

**컨테이너 목록 항목 설명**   
* CONTAINER ID : 
    * 컨테이너에게 자동으로 할당되는 고유한 ID 
    * 목록 출력시 일부만 나오지만, docker inspect 명령어 사용시 전체 ID 확인 가능 
* IMAGE : 
    * 컨테이너를 생성할 때 사용된 이미지의 이름
* COMMAND : 
    * 컨테이너 시작시 실행될 명령어
    * 이미지에 내장된 커멘드는   
      docker run 이나 create 명령어의 맨 끝에 입력해서 컨테이너를 생성할 때 덮어 쓸 수 있다.
    * docker run 저장소/이미지:태그 명령어
* CREATED :
    * 컨테이너가 생성되고 난 뒤 흐른 시간을 나타낸다.   
* STATUS :  
    * 컨테이너 상태
        * Up : 실행중
        * Exited : 종료된 상태
        * Pause : 일시 중지 
* PORTS : 
    * 컨테이너가 개방한 포트와 호스트에 연결한 포트를 나열한다. 
* NAMES : 
    * 컨테이너 고유 이름
    * --name 옵션 : 지정 이름
    * 미옵션 : 형용사와 명사 무작위 조합  

### 컨테이너 삭제

```
docker stop 이미지_이름(or ID)
```
* 컨테이너 중지 

```
docker rm 이미지_이름(or ID)
```
* 컨테이너 삭제(중단된 상태에서 가능)
* -f 옵션으로 강제 삭제 가능하다.

```
docker container purne
````
* 모든 컨테이너 삭제 

```
docker stop $(docker ps -a -q)
docker stop $(docker ps -a -q)
```
* 아이드를 통해 삭제하는 방법 
* -a : 모든 컨테이너
* -q : 컨테이너 ID 만 출력 

## 컨테이너 외부 노출 

**컨테이너는 가상 머신과 마찬가지로 가상 IP 주소를 할당 받는다.**      
기본적으로 `172.17.0.x` IP를 순차적으로 할당한다.  
아무런 설정을 하지 않았다면, 컨테이너 외부에서 접근할 수 없으며 도커가 설치된 호스트만 접근이 가능하다.   
   
외부에 컨테이너 애플리케이션을 노출하기 위해서는     
**eth0의 IP와 포트를 호스트의 IP와 포트에 바인딩 해야한다.**  

```
docker run -p 호스트포트:컨테이너포트 저장소/이미지:태그 
```
* 바인딩할 포트와 공개할 포트를 작성한다.    
* 애플리케이션은 각각의 포트를 사용하는데 그 포트로 여는 것이 좋다.  
* 정확히 말하면 `호스트 IP의 80번 포트` -> `80번 포트는 컨테이너의 80번 포트로 포워딩` -> `웹 서버 접근`
 
```
docker run -p 호스트포트:컨테이너포트 -p 호스트포트:컨테이너포트 저장소/이미지:태그 
```
* 여러 포트를 바인딩 할 수 있다. 

## 컨테이너 애플리케이션 구축  

대부분의 서비스는 단일 프로그램이 아닌,     
여러 에이전트나 데이터베이스등과 연결되어 완전한 서비스로써 동작하는것이 일반적    
  
이런 구성요소들을 하나의 이미지로 만들고 실행하지 않고  
긱 칸테이너마다 하나의 애플리케이션을 구동시키면, 독립성 보장과 동시에 버전관리, 모듈화등이 쉬워진다.    

## 도커 볼륨 

도커 이미지로 컨테이너를 생성하면 이미지는 읽기 전용이 되며     
컨테이너의 변경 사항만 별도로 저장해서 각 컨테이너의 정보를 보존한다.  
즉, 이미지는 어떠한 경우도 변경되지 않으며 컨테이너 계층에 원래 이미지에서 변경된 파일 시스템들을 저장한다.    
 
그러나 이는, 컨테이너마다 데이터가 초기화 된다는 것을 의미하기도 한다.       
이를 방지하기 위해 컨테이너의 데이터를 영속적 데이터로 활용할 수 있는 방법들이 여럿 있다.  
그 중에서 볼륨을 확인해보자.   

* 호스트와 볼륨 공유
    * 호스트와 컨테이너의 디렉터리가 공유되는 방식  
    * `-v [호스트의 공유 디렉터리]:[컨테이너의 공유 디렉터리]` 
    * 호스트의 디렉터리가 없었어도 알아서 만들어준다.  
    * 동기화가 아니라 완전히 같은 디렉터리이다.  
    * 디렉터리 뿐만 아니라 파일 단위의 공유도 가능하며, 여럿도 가능하다.  
    * 만약 디렉터리가 같다면 -> host 디렉터리로 덮어진다.(파일도 host 의 파일로)
* 볼륨 컨테이너
    * 볼륨을 사용하는 다른 컨테이너와 공유하는 방식
    * --volumes-from 옵션을 통해 이미 -v(-volume)으로 만들어진 컨테이너와 볼륨 공유 
    * `--vloumes-from -v 된 컨테이너 이름`
    *  이를 잘 활용하면 볼륨 컨테이너를 만들어서 활용 가능 
* 도커가 관리하는 볼륨 생성  
    * docker volume 명령어를 활용 
    *  

### 볼륨 






 
